/*===========================================================================*\
 *                                                                           *
 *                           Halftone QR Codes                               *
 *                   Copyright (C) 2012 by Hung-Kuo Chu                      *
 * http://cgv.cs.nthu.edu.tw/projects/Recreational_Graphics/Halftone_QRCodes *
 *                                                                           *
 *---------------------------------------------------------------------------*
 *                                                                           *
 *  Halftone QR Codes is free software: you can redistribute it              *
 *  and/or modify it under the terms of the GNU Lesser General Public        *
 *  License as published by the Free Software Foundation, either version     *
 *  3 of the License, or (at your option) any later version with the         *
 *  following exceptions:                                                    *
 *                                                                           *
 *  If other files instantiate templates or use macros                       *
 *  or inline functions from this file, or you compile this file and         *
 *  link it with other files to produce an executable, this file does        *
 *  not by itself cause the resulting executable to be covered by the        *
 *  GNU Lesser General Public License. This exception does not however       *
 *  invalidate any other reasons why the executable file might be            *
 *  covered by the GNU Lesser General Public License.                        *
 *                                                                           *
 *  Halftone QR Codes is distributed in the hope that it will be             *
 *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty      *
 *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *
 *  See the GNU Lesser General Public License for more details.              *
 *                                                                           *
 *  You should have received a copy of the GNU LesserGeneral Public          *
 *  License along with Visual QR Code Generator.                             *
 *  If not, see <http://www.gnu.org/licenses/>.                              *
 *                                                                           *
\*===========================================================================*/ 


#pragma once
/**
*	@brief Header files for the C++ utility library
*/
#include <cassert>
#include <utility>
#include <omp.h>
#include <Windows.h>
#include <stdlib.h>
/**
*	@brief Header files for the STL library
*/
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <cmath>
#include <list>
#include <limits>
#include <algorithm>
#include <functional>
#include <numeric>
#include <random>
#include <sstream>
#include <strstream>
#include <exception>
#include <unordered_map>
#include <unordered_set>
using namespace std;
/**
*	@brief Header files for QR code generator Library
*/
#include "qrencode/Include/qrencode.h"
#include "qrencode/Include/qrspec.h"
#ifdef NDEBUG
#pragma comment( lib, "qrencode/Lib/qrencode.lib" )
#pragma message( "Link with QREncode.lib" )
#else
#pragma comment( lib, "qrencode/Lib/qrencoded.lib" )
#pragma message( "Link with QREncoded.lib." )
#endif
/**
*	@brief Header files for the boost
*/
#include <boost/graph/adjacency_list.hpp>
/**
*	@brief Header files for OpenCV library 2.4.1
*/
/// Disable warnings generated by OpenCV
/// 'cv::XXXX' : function compiled as native
#pragma warning( disable:4793 )
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#define LIBFILE(x) x ".lib"
#define LIBdFILE(x) x "d.lib"
#include <OpenCV2\opencv.hpp>
#define OPENCV_VER 249
#define OPENCV_CORE "opencv_core" TOSTRING(OPENCV_VER)
#define OPENCV_IMGPROC "opencv_imgproc" TOSTRING(OPENCV_VER)
#define OPENCV_HIGHGUI "opencv_highgui" TOSTRING(OPENCV_VER)
#define OPENCV_VIDEO "opencv_video" TOSTRING(OPENCV_VER)
#define OPENCV_FEATURES2D "opencv_features2d" TOSTRING(OPENCV_VER)
#define OPENCV_OBJDETECT "opencv_objdetect" TOSTRING(OPENCV_VER)
#define OPENCV_ML "opencv_ml" TOSTRING(OPENCV_VER)
#define OPENCV_CALIB3D "opencv_calib3d" TOSTRING(OPENCV_VER)
#define OPENCV_CONTRIB "opencv_contrib" TOSTRING(OPENCV_VER)
#define OPENCV_LEGACY "opencv_legacy" TOSTRING(OPENCV_VER)
#define OPENCV_FLANN "opencv_flann" TOSTRING(OPENCV_VER)
#ifdef NDEBUG
#pragma comment( lib, LIBFILE(OPENCV_CORE))
#pragma message( "Link with " LIBFILE(OPENCV_CORE) )
#pragma comment( lib, LIBFILE(OPENCV_IMGPROC) )
#pragma message( "Link with " LIBFILE(OPENCV_IMGPROC) )
#pragma comment( lib, LIBFILE(OPENCV_HIGHGUI) )
#pragma message( "Link with " LIBFILE(OPENCV_HIGHGUI) )
#pragma comment( lib, LIBFILE(OPENCV_VIDEO) )
#pragma message( "Link with " LIBFILE(OPENCV_VIDEO) )
#pragma comment( lib, LIBFILE(OPENCV_FEATURES2D) )
#pragma message( "Link with " LIBFILE(OPENCV_FEATURES2D) )
#pragma comment( lib, LIBFILE(OPENCV_OBJDETECT) )
#pragma message( "Link with " LIBFILE(OPENCV_OBJDETECT) )
//#pragma comment( lib, LIBFILE(OPENCV_ML) )
//#pragma message( "Link with " LIBFILE(OPENCV_ML) )
//#pragma comment( lib, LIBFILE(OPENCV_CALIB3D) )
//#pragma message( "Link with " LIBFILE(OPENCV_CALIB3D) )
//#pragma comment( lib, LIBFILE(OPENCV_CONTRIB) )
//#pragma message( "Link with " LIBFILE(OPENCV_CONTRIB) )
//#pragma comment( lib, LIBFILE(OPENCV_LEGACY) )
//#pragma message( "Link with " LIBFILE(OPENCV_LEGACY) )
//#pragma comment( lib, LIBFILE(OPENCV_FLANN) )
//#pragma message( "Link with " LIBFILE(OPENCV_FLANN) )
#else
#pragma comment( lib, LIBdFILE(OPENCV_CORE))
#pragma message( "Link with " LIBdFILE(OPENCV_CORE) )
#pragma comment( lib, LIBdFILE(OPENCV_IMGPROC) )
#pragma message( "Link with " LIBdFILE(OPENCV_IMGPROC) )
#pragma comment( lib, LIBdFILE(OPENCV_HIGHGUI) )
#pragma message( "Link with " LIBdFILE(OPENCV_HIGHGUI) )
#pragma comment( lib, LIBdFILE(OPENCV_VIDEO) )
#pragma message( "Link with " LIBdFILE(OPENCV_VIDEO) )
#pragma comment( lib, LIBdFILE(OPENCV_FEATURES2D) )
#pragma message( "Link with " LIBdFILE(OPENCV_FEATURES2D) )
#pragma comment( lib, LIBdFILE(OPENCV_OBJDETECT) )
#pragma message( "Link with " LIBdFILE(OPENCV_OBJDETECT) )
//#pragma comment( lib, LIBdFILE(OPENCV_ML) )
//#pragma message( "Link with " LIBdFILE(OPENCV_ML) )
//#pragma comment( lib, LIBdFILE(OPENCV_CALIB3D) )
//#pragma message( "Link with " LIBdFILE(OPENCV_CALIB3D) )
//#pragma comment( lib, LIBdFILE(OPENCV_CONTRIB) )
//#pragma message( "Link with " LIBdFILE(OPENCV_CONTRIB) )
//#pragma comment( lib, LIBdFILE(OPENCV_LEGACY) )
//#pragma message( "Link with " LIBdFILE(OPENCV_LEGACY) )
//#pragma comment( lib, LIBdFILE(OPENCV_FLANN) )
//#pragma message( "Link with " LIBdFILE(OPENCV_FLANN) )
#endif

/*
*	@brief Header files for GCoptimization library
*/
#include "GCO/GCoptimization.h"
#ifdef NDEBUG
#pragma comment( lib, "GCO/lib/GCoptimization.lib" )
#pragma message( "Link with GCoptimization.lib" )
#else
#pragma comment( lib, "GCO/lib/GCoptimizationd.lib" )
#pragma message( "Link with GCoptimizationd.lib" )
#endif
#include "GCO/LinkedBlockList.h"
#ifdef NDEBUG
#pragma comment( lib, "GCO/lib/LinkedBlockList.lib" )
#pragma message( "Link with LinkedBlockList.lib" )
#else
#pragma comment( lib, "GCO/lib/LinkedBlockListd.lib" )
#pragma message( "Link with LinkedBlockListd.lib" )
#endif

using namespace std;
using namespace System;	
using namespace System::Collections;
using namespace System::Collections::Generic;
using namespace cv;
/// Convert System::String to std::string
inline std::string MarshalString(System::String^ s)
{
	using namespace System::Runtime::InteropServices;
	const char* chars = (const char*)(Marshal::StringToHGlobalAnsi(s)).ToPointer();
	std::string os(chars);	
	Marshal::FreeHGlobal(System::IntPtr((void*)chars));
	return os;
}
template<class T>
void Free_VecPtr(vector<T>& _vec)
{
	vector<T>::iterator item_it;
	for(item_it = _vec.begin(); item_it != _vec.end(); ++item_it)
		delete (*item_it);
	_vec.clear();
}

namespace HQRCdata
{
	class		HKCModule;
}
namespace boost {

	enum vertex_element_t { vertex_element };
	BOOST_INSTALL_PROPERTY(vertex, element);
}

typedef vector<cv::Mat>		VecMat;
/// type define for boost graph edge property
typedef boost::property<boost::edge_weight_t, double> GEPropT;	
/// type define for boost graph vertex property	
typedef boost::property<boost::vertex_element_t, HQRCdata::HKCModule*> GVPropT;
/// type define for boost graph
typedef boost::adjacency_list<boost::setS, boost::vecS, boost::undirectedS, GVPropT, GEPropT> GraphT;
/// type define for boost graph edge descriptor and iterators
typedef boost::graph_traits<GraphT>::edge_descriptor				GEDescT;
typedef boost::graph_traits<GraphT>::edge_iterator					GEIterT;
/// type define for boost graph vertex index map and data type
typedef boost::property_map<GraphT, boost::vertex_index_t>::type	GVIndexM;
/// type define for boost graph vertex descriptor and iterators
typedef boost::graph_traits<GraphT>::vertex_descriptor				GVDescT;
typedef boost::graph_traits<GraphT>::vertex_iterator				GVIterT;
/// type define for boost graph vertex element map and data type
typedef boost::property_map<GraphT, boost::vertex_element_t>::type	GVElemntM;	
typedef boost::property_traits<GVElemntM>::value_type				GVElemntT;
/// type define for boost graph edge weight map and data type
typedef boost::property_map<GraphT, boost::edge_weight_t>::type		GEWeightM;
typedef boost::property_traits<GEWeightM>::value_type				GEWeightT;

namespace NFSSIM
	{
		struct NFParam
		{
			int Channel;
			int Method;
			double K1;
			double K2;
			int L;
			int DownsampleWidth;
			int GaussKernel;
			double GaussSigma;	

			NFParam(void) : Channel(0), Method(CV_BGR2YUV), K1(0.01), K2(0.03), L(255), DownsampleWidth(256), GaussKernel(11), GaussSigma(1.5) {}
		};		

		double calcSSIM(cv::Mat& src1, cv::Mat& src2, int channel = 0, int method=CV_BGR2YUV, cv::Mat& mask=cv::Mat(),const double K1 = 0.01, const double K2 = 0.03,	const int L = 255, const int downsamplewidth=256, const int gaussian_window=11, const double gaussian_sigma=1.5, cv::Mat& ssim_map=cv::Mat());
		double calcSSIMBB(cv::Mat& src1, cv::Mat& src2, int channel = 0, int method=CV_BGR2YUV, int boundx=0,int boundy=0,const double K1 = 0.01, const double K2 = 0.03,	const int L = 255, const int downsamplewidth=256, const int gaussian_window=11, const double gaussian_sigma=1.5, cv::Mat& ssim_map=cv::Mat());

		double calcDSSIM(cv::Mat& src1, cv::Mat& src2, int channel = 0, int method=CV_BGR2YUV, cv::Mat& mask=cv::Mat(),const double K1 = 0.01, const double K2 = 0.03,	const int L = 255, const int downsamplewidth=256, const int gaussian_window=11, const double gaussian_sigma=1.5, cv::Mat& ssim_map=cv::Mat());
		double calcDSSIMBB(cv::Mat& src1, cv::Mat& src2, int channel = 0, int method=CV_BGR2YUV, int boundx=0,int boundy=0,const double K1 = 0.01, const double K2 = 0.03,	const int L = 255, const int downsamplewidth=256, const int gaussian_window=11, const double gaussian_sigma=1.5, cv::Mat& ssim_map=cv::Mat());

		/**
		*	@brief James: Some convenient overloaded functions
		*/
		double inline calcSSIM(cv::Mat& src1, cv::Mat& src2, NFParam& param, cv::Mat& mask=cv::Mat(), cv::Mat& ssim_map=cv::Mat())
		{
			return calcSSIM(src1, src2, param.Channel, param.Method, mask, param.K1, param.K2, param.L, param.DownsampleWidth, param.GaussKernel, param.GaussSigma, ssim_map);
		}
		double inline calcSSIMBB(cv::Mat& src1, cv::Mat& src2, NFParam& param, int boundx=0,int boundy=0, cv::Mat& ssim_map=cv::Mat())
		{
			return calcSSIMBB(src1, src2, param.Channel, param.Method, boundx, boundy, param.K1, param.K2, param.L, param.DownsampleWidth, param.GaussKernel, param.GaussSigma, ssim_map);
		}

		double inline calcDSSIM(cv::Mat& src1, cv::Mat& src2, NFParam& param, cv::Mat& mask=cv::Mat(), cv::Mat& ssim_map=cv::Mat())
		{
			return calcDSSIM(src1, src2, param.Channel, param.Method, mask, param.K1, param.K2, param.L, param.DownsampleWidth, param.GaussKernel, param.GaussSigma, ssim_map);
		}
		double inline calcDSSIMBB(cv::Mat& src1, cv::Mat& src2, NFParam& param, int boundx=0,int boundy=0, cv::Mat& ssim_map=cv::Mat())
		{
			return calcDSSIMBB(src1, src2, param.Channel, param.Method, boundx, boundy, param.K1, param.K2, param.L, param.DownsampleWidth, param.GaussKernel, param.GaussSigma, ssim_map);
		}
	}	
public ref class HQRCGlobal abstract sealed
{
	public:
		static bool				g_Debug = true;			///< Flag of debug mode
		static System::String^	g_AppDir;				///< Folder of the application executable
		static System::String^	g_PrjDir;				///< Folder of the project
		static System::String^  g_DebugDir;				///< Folder of the debug file
};
namespace Similarity
{
	/**
	*	@brief Base class for the pattern similarity interface
	*/	
	public ref class HKCPSFunc abstract
	{
		/*==========================  PUBLIC  =================================*/
	public:					
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		virtual ~HKCPSFunc(void) {}		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Similarity function						   */
		/*! \{                                                                 */	

		/// Compute the similarity
		virtual double Compute(const cv::Mat&, const cv::Mat&) = 0;

		/// Normalize the similarity map
		virtual void Normalize(cv::Mat&, double, double) = 0;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		virtual System::String^ ToString() override
		{
			return L"Pattern Similarity Function";
		}		

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:				
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCPSFunc(void) {}						

		/*! \}                                                                 */		
	};

	/**
	*	@brief Base class for the SSIM pattern similarity
	*          The larger the SSIM between two patterns is, the larger the similarity between them is
	*          This value is between 0 and 1, where 1 corresponds to perfect fit
	*/	
	public ref class HKCPSSSIM : public HKCPSFunc
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCPSSSIM(void) {}						

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		virtual ~HKCPSSSIM(void) {}		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Similarity function						   */
		/*! \{                                                                 */	

		/// Compute the similarity
		virtual double Compute(const cv::Mat& _m1, const cv::Mat& _m2) override
		{				
			cv::Mat m1 = _m1, m2 = _m2;	
			NFSSIM::NFParam nfParam;			
			nfParam.GaussKernel = 3;
			nfParam.GaussSigma = 0.0;
			return NFSSIM::calcSSIM(m1, m2, nfParam);				
		}

		/// Normalize the similarity map 
		/// Make sure that similar patterns have lower value 
		/// The value of SSIM is between 0 and 1, where 1 corresponds to perfect fit
		virtual void Normalize(cv::Mat& _m, double _min, double _max) override
		{
			cv::normalize(_m, _m, _min, _max, NORM_MINMAX);
			_m = cv::Scalar::all(_max) - _m;
		}

		/*! \}                                                                 */	
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		virtual System::String^ ToString() override
		{
			return L"SSIM";
		}		

		/*! \}                                                                 */
	};

}
namespace HQRCdata
{	
	//define
	class HKCModule;
	/// type define for the vector of QR code module
	typedef vector<HKCModule*> VecMdu;
	/*
	*	@brief Enumeration of QR code error correction level
	*/
	public enum class HKEECL
	{		
		ECL_L=0, ECL_M, ECL_Q, ECL_H 
	};		

	/**
	*	@brief Class for the QR code parameters
	*/
	public ref class HKCQRCParam
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCQRCParam(void)
		{		
			m_Ver = 0;
			m_ECL = HKEECL::ECL_L;
		}
		HKCQRCParam(std::string text,int ver,HKEECL ECL )
		{
			m_Text = gcnew System::String(text.c_str());
			m_Ver=ver;
			m_ECL=ECL;
		}
		HKCQRCParam(System::String^ text)
		{
			m_Text=text;
			m_Ver=5;
			m_ECL=HKEECL::ECL_H;
		}
		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCQRCParam(void) 
		{
		}	

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */		
		
		property System::String^ Text
		{
			System::String^ get(void) { return m_Text; }
			void set(System::String^ value) 
			{ 
				if(System::String::Compare(m_Text, value) != 0)
				{
					m_Text = value;
				}				
			}
		}

		property int Version
		{
			int get(void) { return m_Ver; }
			void set(int value) 
			{ 
				if(m_Ver != value)
					m_Ver = value;		
			}
		}

		property HKEECL ECLvl
		{
			HKEECL get(void) { return m_ECL; }
			void set(HKEECL value) 
			{ 
				if(m_ECL != value)
				{
					m_ECL = value;						
				}				
			}
		}

		property int RSNum;		

		property int ECCap;				

		virtual System::String^ ToString() override
		{
			return "QR Code Parameters";
		}

		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	private:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */	

		System::String^	m_Text;		///< QR code text
		int				m_Ver;		///< QR code version
		HKEECL			m_ECL;		///< QR code error correction level		

		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the pattern database parameters
	*/
	public ref class HKCPDBParam
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCPDBParam(void)
		{					
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCPDBParam(void) 
		{
		}	
		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */		
					
		property int PSize
		{
			int get(void) { return m_PSize; }
			void set(int value) 
			{ 
				if(m_PSize != value)
				{
					m_PSize = value;
				}				
			}
		}		
		virtual System::String^ ToString() override
		{
			return "Pattern Database Parameters";
		}

		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	private:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */	
			
		int				m_PSize;	///< Pattern size		

		/*! \}                                                                 */
	};	

	/**
	*	@brief Class for the pattern assignment parameters
	*/
	public ref class HKCOptmParam
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCOptmParam(void)
		{
			NScale		= 100.0;
			WeightS		= 0.2;
			WeightR		= 0.0;
			SigmaS		= 20;
			SigmaR		= 10;
			SigmaM      = 10;
			MaxECNum	= -1;
			NormRel     = false;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCOptmParam(void) 
		{
		}	
		


		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */		

		property double NScale;
		property double WeightS;
		property double WeightR;
		property double SigmaS;
		property double SigmaR;
		property double SigmaM;
		property int MaxECNum;
		property bool NormRel;
		virtual System::String^ ToString() override
		{
			return "Pattern Assignment Parameters";
		}

		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	private:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */
		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the application parameters
	*/
	public ref class HKCAppParam
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCAppParam(void) 
		{			
			mp_QRC		= gcnew HKCQRCParam;
			mp_PDB		= gcnew HKCPDBParam;			
			mp_Optm		= gcnew HKCOptmParam;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCAppParam(void) 
		{			

			delete mp_QRC;
			mp_QRC = nullptr;

			delete mp_PDB;
			mp_PDB = nullptr;			

			delete mp_Optm;
			mp_Optm = nullptr;

		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */
		
		property HKCQRCParam^ QRCode
		{
			HKCQRCParam^ get(void) { return mp_QRC; }
		}
		
		property HKCPDBParam^ PDB
		{
			HKCPDBParam^ get(void) { return mp_PDB; }
		}		
		
		property HKCOptmParam^ Optimize
		{
			HKCOptmParam^ get(void) { return mp_Optm; }
		}
		
		
		virtual System::String^ ToString() override
		{
			return "Application Parameters";
		}

		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	private:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{																   */
		HKCQRCParam^	mp_QRC;
		HKCPDBParam^	mp_PDB;		
		HKCOptmParam^	mp_Optm;

		/*! \}                                                                 */
	};
	
	
	/**
	*	@brief Class for the image data
	*/
	class HKCImgData
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCImgData(void) { Clear(); }		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCImgData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/		
		/*! \name                    Initialization                            */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void) 
		{
			isReady = false;
			SrcImg.release();
			RGBImg.release();			
			Mask.release();
			HalftoneImg.release();
			EdgeMap.release();
			UserMap.release();
			ImpMap.release();
		}		

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		bool	isReady;	///< Flag indicates if the data is ready
		cv::Mat SrcImg;     ///< Source image
		cv::Mat	RGBImg;		///< Source image in RGB color space
		cv::Mat RstImg;		///< Resutl image in RGB color space
		cv::Mat	Mask;		///< Source image mask
		cv::Mat HalftoneImg;///< Halftone image	
		cv::Mat EdgeMap;	///< Source edge map
		cv::Mat UserMap;	///< Saliency map drown by user
		cv::Mat ImpMap;		///< Importance map with type CV_64FC1 and has the same size of original QR code image)

		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the QR code module
	*/
	class HKCModule
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCModule(void) { Clear(); }		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCModule(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/		
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void) 
		{	
			Type = -1;
			Pos = cv::Point(0,0);
			QRC = -1;
			RSID = -1;
			CWID = -1;	
			PID1 = -1;
			PID2 = -1;
			VID = -1;
			Weit = -1.0;
		}		

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		/// 0:Codewords
		/// 1:Remaining Bits
		/// 2:Version Information
		/// 3:Format Information 
		/// 4:Alignment Patterns
		/// 5:Timing Patterns
		/// 6:Separators and Position Detection Patterns
		int         Type;   ///< Type of module
		cv::Point   Pos;	///< Module's position		
		int         QRC;	///< QR code value (1: black, 0: white)
		int			RSID;	///< RS block ID (1-based index, -1 indicates non data module)
		int			CWID;	///< Codeword ID in the RS block (1-based index, -1 indicates non data module)	
		int			PID1;	///< Ideal/Original pattern ID
		int         PID2;   ///< Optimal pattern ID
		int   VID;	///< Vertex index in the graph
		double		Weit;	///< Importance of the module (0-1, -1 indicates non data module)
		
		/*! \}                                                                 */
	};

	

	/**
	*	@brief Class for the QR code code word
	*/
	class HKCCodeWord
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCCodeWord(void) { Clear(); }		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCCodeWord(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Functors                                 */
		/*! \{                                                                 */

		class Priority_GreatThan
		{
		public:
			bool operator()(HKCCodeWord* _lhs, HKCCodeWord* _rhs) { return _lhs->Priority > _rhs->Priority; }
		};

		/*! \}                                                                 */	
		/*---------------------------------------------------------------------*/		
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void) 
		{
			Tag = -1;
			RVal = 0.0;			
			Weit = 0.0;						
			Priority = 0;
			Modules.clear();
		}		

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		int		Tag;		///< -1: non-used codeword
		double	RVal;		///< Reliability		
		double	Weit;		///< Modules' averaged importance				
		double  Priority;	///< Priority of codeword
		VecMdu	Modules;	///< Modules (Store only pointers)

		/*! \}                                                                 */
	};

	/// type define for the vector of QR code code word
	typedef vector<HKCCodeWord*> VecCW;

	/**
	*	@brief Class for the QR code RS block
	*/
	class HKCRSBlock
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCRSBlock(void) { Clear(); }		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCRSBlock(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/		
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void) 
		{
			Tag = -1;
			RVal = 0.0;
			Free_VecPtr(CodeWords);
		}		

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		int		Tag;		///< -1: non-used RS block
		double	RVal;		///< Reliability
		VecCW	CodeWords;	///< Code words

		/*! \}                                                                 */
	};

	/// type define for the vector of QR code code word
	typedef vector<HKCRSBlock*>	VecRSB;

	/**
	*	@brief Class for the QR code data
	*/
	class HKCQRCData
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCQRCData(void) { Clear(); }		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCQRCData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/		
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void) 
		{	
			isReady = false;
			Text = "";
			Ver = -1;
			ECL = -1;
			ECC = -1;						
			QRCode.release();
			QRCImg.release();
			RSMap.release();
			CWMap.release();			
			Free_VecPtr(Modules);
			Free_VecPtr(RSBlocks);
			MdGraph.clear();			
		}		

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		bool			isReady;	///< Flag indicates if the data is ready
		std::string		Text;		///< Encoded text string
		int				Ver;		///< QR code version (5, 10)
		int				ECL;		///< Error correction level
		int				ECC;		///< Error correction capacity		
		cv::Mat			QRCode;		///< Original QR code (8UC1)
		cv::Mat			QRCImg;		///< Upsample version QR code image (8UC1)
		cv::Mat			RSMap;		///< RS block map (CV_32SC1, 1-based index and value -1 indicates non-used pixel)
		cv::Mat			CWMap;		///< Code word map (CV_32SC1, 1-based index and value -1 indicates non-used pixel)		
		VecMdu			Modules;	///< QR code modules	
		VecRSB			RSBlocks;	///< QR code RS blocks
		GraphT			MdGraph;	///< Modules involve in the optimization (Store only pointers)			
		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the image pattern
	*/
	class HKCPattern
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCPattern(void) { Clear(); }		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCPattern(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/		
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void) 
		{			
			ID		= -1;
			Tag		= -1;			
			RVal	= 0.0;
			RVal2   = 0.0;
			Img.release();
		}		

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */		

		int		ID;		///< Pattern ID
		int		Tag;	///< Color of center pixel (1: black, 0: white)
		cv::Mat	Img;	///< Binary pattern image, white(255) and black(0)			
		double  RVal;	///< Reliability
		double	RVal2;	///< Original Reliability

		/*! \}                                                                 */
	};

	/// type define for the vector of image pattern
	typedef vector<HKCPattern*>	VecPtrn;

	/**
	*	@brief Class for the pattern database
	*/
	class HKCPDBData
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCPDBData(void) { Clear(); }		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCPDBData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/		
		/*! \name                      Methods                                 */
		/*! \{                                                                 */


		/// Clear data
		void Clear(void) 
		{	
			isReady = false;			
			PSize = -1;
			Free_VecPtr(Patterns);	
			Whites.clear();
			Blacks.clear();
			SimMap.release();
		}		

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		bool			isReady;	///< Flag indicates if the data is ready				
		int				PSize;		///< Pattern size (3X3)				
		VecPtrn			Patterns;	///< Image patterns	
		VecPtrn			Whites;		///< Patterns whose center pixel are white(0)
		VecPtrn			Blacks;		///< Patterns whose center pixel are black(1)
		cv::Mat			SimMap;		///< Similarity map

		/*! \}																	*/
	};

	/**
	*	@brief Class for the application data
	*/
	class HKCAppData
	{
		/*==========================  PUBLIC  =================================*/
	public:		
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCAppData(void) { Clear(); }		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCAppData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/		
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// clear data
		void Clear(void) 
		{
			ImgData.Clear();
			QRCData.Clear();
			PDBData.Clear();
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		HKCImgData	ImgData;
		HKCQRCData	QRCData;
		HKCPDBData	PDBData;

		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the application item
	*/
	public ref class HKCAppItem
	{
		/*==========================  PUBLIC  =================================*/
	public:	
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCAppItem(void)
		{
			mp_param = gcnew HKCAppParam;
			mp_Data		= new HKCAppData;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		~HKCAppItem(void)
		{	
			mp_param = nullptr;
			mp_Data = NULL;
		}

		/*! \}                                                                 */	
		/*---------------------------------------------------------------------*/		
		/*! \name                   Item Operations                            */
		/*! \{                                                                 */

		property HKCAppData* Data
		{
			HKCAppData* get(void) { return mp_Data; }			
		}		
		property HKCAppParam^ Param
		{
			HKCAppParam^ get(void) { return mp_param; }
		}
		void setrgbimg(cv::Mat rgbimg)
		{
			mp_Data->ImgData.RGBImg=rgbimg;
		}
		void setusermap(cv::Mat usermap)
		{
			mp_Data->ImgData.UserMap=usermap;
		}
		void setsrcimg(cv::Mat srcimg)
		{
			mp_Data->ImgData.SrcImg=srcimg;
		}
		


		/*! \}                                                                 */		
		/*==========================  PRIVATE  ================================*/
	private:
		/*---------------------------------------------------------------------*/
		/*! \name                        Data								   */
		/*! \{                                                                 */

		HKCAppData*				mp_Data;		///< Application data		
		HKCAppParam^			mp_param;
		/*! \}                                                                 */
	};
}
namespace energy
{
		/// Similarity energy	
	class SimEnrgyNoPenalty
	{
		/*==========================  PUBLIC  =================================*/
	public:			 
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		inline double operator()(HQRCdata::HKCModule*	_m, HQRCdata::HKCPattern*	_p, cv::Mat& _simMap, HQRCdata::HKCOptmParam^ _param) 
		{ 			
			//return _m->Weit*_simMap.at<double>(_p->ID, _m->PID1);			
			return _simMap.at<double>(_p->ID, _m->PID1);			
		}		

		/*! \}                                                                 */
	};

	/// Similarity energy: Penalize similarity term if module->QRC != pattern->Tag
	class SimEnrgyWithPenalty
	{
		/*==========================  PUBLIC  =================================*/
	public:			 
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		inline double operator()(HQRCdata::HKCModule*	_m,HQRCdata::HKCPattern*	_p, cv::Mat& _simMap, HQRCdata::HKCOptmParam^ _param) 
		{ 		
			/*double sVal = (_m->QRC == _p->Tag) ? _simMap.at<double>(_p->ID, _m->PID1) : 1.0;
			return _m->Weit*sVal;*/

			//return (_m->QRC == _p->Tag) ? _m->Weit*_simMap.at<double>(_p->ID, _m->PID1) : 10.0;
			return (_m->QRC == _p->Tag) ? _simMap.at<double>(_p->ID, _m->PID1) : 1.0;				
		}		

		/*! \}                                                                 */
	};

	/// Reliability energy: Compute linear reliability energy
	class RelEnrgyLinear
	{
		/*==========================  PUBLIC  =================================*/
	public:			 
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		inline double operator()(HQRCdata::HKCModule*	_m, HQRCdata::HKCPattern*	_p, HQRCdata::HKCOptmParam^ _param) 
		{ 			
			double rVal = (_m->QRC == _p->Tag) ? fabs(1.0-_p->RVal) : 1.0;
			
			//return Math::Sqrt(_param->WeightR*(1.0-_m->Weit))*rVal;
			//return _param->WeightR*fabs(1.0-_m->Weit)*rVal;
			return _param->WeightR*Math::Exp(_m->Weit*-_param->SigmaM)*rVal;			
		}		

		/*! \}                                                                 */
	};
	
	/// Reliability energy: Compute exponential reliability energy	
	class RelEnrgyExp
	{
		/*==========================  PUBLIC  =================================*/
	public:			 
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		inline double operator()(HQRCdata::HKCModule*	_m,HQRCdata:: HKCPattern*	_p, HQRCdata::HKCOptmParam^ _param) 
		{ 
			double rVal = (_m->QRC == _p->Tag) ? Math::Exp(_p->RVal*-_param->SigmaR) : 1.0;
			
			//return Math::Sqrt(_param->WeightR*(1.0-_m->Weit))*rVal;			
			//return _param->WeightR*fabs(1.0-_m->Weit)*rVal;
			return _param->WeightR*Math::Exp(_m->Weit*-_param->SigmaM)*rVal;
		}		

		/*! \}                                                                 */
	};

	/// Compute the total energy function
	template<class SimEnrgyT, class RelEnrgyT>
	class EnergyFunc
	{
		/*==========================  PUBLIC  =================================*/
	public:			 
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		EnergyFunc(SimEnrgyT& _simEnrgy, RelEnrgyT& _relEnrgy, HQRCdata::VecPtrn& _patterns, cv::Mat&	_simMap, GraphT& _graph) 
			: m_SimEnrgy(_simEnrgy), m_RelEnrgy(_relEnrgy), m_Patterns(_patterns), m_SimMap(_simMap), m_Graph(_graph)
		{
			m_VelmtMap = boost::get(boost::vertex_element, m_Graph);
			m_EWeitMap = boost::get(boost::edge_weight, m_Graph);
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */		

		/// DataCost		
		inline double DataCost(int _m, int _l, HQRCdata::HKCOptmParam^ _param) 
		{ 			
			HKCModule* m_pt = m_VelmtMap[_m];
			HKCPattern* p_pt = m_Patterns[_l];

			double simVal = m_SimEnrgy(m_pt, p_pt, m_SimMap, _param);						
			double relVal = m_RelEnrgy(m_pt, p_pt, _param);						
			return (simVal + relVal);
		}			

		inline double DataCostNoPenalty(int _m, int _l, HQRCdata::HKCOptmParam^ _param) 
		{ 			
			HKCModule* m_pt = m_VelmtMap[_m];
			HKCPattern* p_pt = m_Patterns[_l];

			SimEnrgyNoPenalty simEnrgy;
			double simVal = simEnrgy(m_pt, p_pt, m_SimMap, _param);						
			double relVal = m_RelEnrgy(m_pt, p_pt, _param);						
			return (simVal + relVal);
		}

		inline double EdgeWeight(GEDescT _e, HQRCdata::HKCOptmParam^ _param)
		{
			return _param->WeightS*m_EWeitMap[_e];
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:		
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		HQRCdata::VecPtrn&		m_Patterns;
		cv::Mat&		m_SimMap;
		GraphT&			m_Graph;
		GVElemntM		m_VelmtMap;
		GEWeightM		m_EWeitMap;
		SimEnrgyT		m_SimEnrgy;
		RelEnrgyT		m_RelEnrgy;

		/*! \}                                                                 */
	};
}
namespace HQRCALGORITHM
{
	/**
	*	@brief Base class for the algorithm interface
	*/
	public ref class HKCAlgorithm abstract
	{
		/*==========================  PUBLIC  =================================*/
	public:					
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		virtual ~HKCAlgorithm(void) {}		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */	

		/// Execute the algorithm
		virtual bool Execute(HQRCdata::HKCAppItem^) = 0;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		virtual property System::String^ Abbrev
		{
			System::String^ get(void) { return "Algo"; }				
		}
		virtual System::String^ ToString() override
		{
			return L"Application Algorithm";
		}		

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:				
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCAlgorithm(void) {}						

		/*! \}                                                                 */
	};	

	/**
	*	@brief Class for the default data initialization
	*/
	public ref class HKCDataInit1 : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:				
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCDataInit1(void) {}						

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		virtual ~HKCDataInit1(void) {}		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */	

		/// Data initialization
		virtual bool Execute(HQRCdata::HKCAppItem^) override;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		virtual property System::String^ Abbrev
		{
			System::String^ get(void) override { return "DataInit1"; }				
		}
		virtual System::String^ ToString() override
		{
			return L"Default Data Initialization";
		}		

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:				
		
	};
	/**
	*	@brief Class for the pattern database process
	*/
	public ref class HKCPDBProc1 : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:				
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCPDBProc1(void) {}						

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		virtual ~HKCPDBProc1(void) {}		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */	

		/// Pre-compute data from database
		virtual bool Execute(HQRCdata::HKCAppItem^) override;

		//static 

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		virtual property System::String^ Abbrev
		{
			System::String^ get(void) override { return "PDBProc1"; }				
		}
		virtual System::String^ ToString() override
		{
			return L"Pattern Database Process";
		}		

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:				
		
	};
	/**
	*	@brief Class for the default QR code generator
	*/
	public ref class HKCQRCGen1 : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:				
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCQRCGen1(void) {}						

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		virtual ~HKCQRCGen1(void) {}		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */	

		/// Generate QR code
		virtual bool Execute(HQRCdata::HKCAppItem^) override;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		virtual property System::String^ Abbrev
		{
			System::String^ get(void) override { return "QRCGen1"; }				
		}
		virtual System::String^ ToString() override
		{
			return L"Default QR code generator";
		}		

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:				
		
	};	
	/**
	*	@brief Class for the base optimization interface
	*/
	public ref class HKCOptimizer abstract : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:				
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		virtual ~HKCOptimizer(void) {}		

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */	

		/// Perform pattern assignment optimization
		virtual bool Execute(HQRCdata::HKCAppItem^ _appItem) override
		{
			if(!Initialize(_appItem))
			{
				Console::WriteLine("HKCOptimizer::Execute() : Initialization failed");
				return false;
			}

			if(!Optimize(_appItem))
			{
				Console::WriteLine("HKCOptimizer::Execute() : Optimization failed");
				return false;
			}

			/// Analyze the optimized result
			Analyze(_appItem);				

			return true;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		virtual property System::String^ Abbrev
		{
			System::String^ get(void) override { return "Optimizer"; }				
		}
		virtual System::String^ ToString() override
		{
			return L"Base Optimization Interface";
		}		

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:	
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCOptimizer(void) {}						

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Internal Operations						   */
		/*! \{                                                                 */

		/// Initialize data used for optimization
		virtual bool Initialize(HQRCdata::HKCAppItem^);

		/// Perform pattern assignment optimization using specific approach
		virtual bool Optimize(HQRCdata::HKCAppItem^) = 0 ;

		/// Analyze the optimized result
		virtual void Analyze(HQRCdata::HKCAppItem^);

		/*! \}                                                                 */		
	};	

	/**
	*	@brief Class for the nearest-neighbors approach.
			   This approach find the most similar pattern with the same value as the original QR code at the center pixel.
	*/
	public ref class HKCNNOptmzr : public HKCOptimizer
	{
		/*==========================  PUBLIC  =================================*/
	public:			
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCNNOptmzr(void) {}						

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */		

		virtual ~HKCNNOptmzr(void) {}		

		/*! \}                                                                 */		
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		virtual property System::String^ Abbrev
		{
			System::String^ get(void) override { return "NN1"; }				
		}
		virtual System::String^ ToString() override
		{
			return L"Nearest-Neighbors Approach 1";
		}		

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:			
		/*---------------------------------------------------------------------*/
		/*! \name                Internal Operations						   */
		/*! \{                                                                 */
	
		/// Perform the optimization
		virtual bool Optimize(HQRCdata::HKCAppItem^) override;

		/*! \}                                                                 */		
	};
	/**
	*	@brief Class for the unconstrained Graph-Cuts.	           
	*/
 	public ref class HKCUGCOptmzr : public HKCOptimizer
 	{
 		/*==========================  PUBLIC  =================================*/
 	public:			
 		/*---------------------------------------------------------------------*/
 		/*! \name                   Constructors                               */
 		/*! \{                                                                 */
 
 		HKCUGCOptmzr(void) {}						
 
 		/*! \}                                                                 */
 		/*---------------------------------------------------------------------*/
 		/*! \name                     Destructor                               */
 		/*! \{                                                                 */		
 
 		virtual ~HKCUGCOptmzr(void) {}		
 
 		/*! \}                                                                 */		
 		/*---------------------------------------------------------------------*/
 		/*! \name                  Access Methods                              */
 		/*! \{                                                                 */
 
 		virtual property System::String^ Abbrev
 		{
 			System::String^ get(void) override { return "UGC"; }				
 		}
 		virtual System::String^ ToString() override
 		{
 			return L"Unconstrained Graph-Cuts";
 		}		
 
 		/*! \}                                                                 */
 		/*=========================  PROTECTED  ===============================*/
 	protected:			
 		/*---------------------------------------------------------------------*/
 		/*! \name                Internal Operations						   */
 		/*! \{                                                                 */
 	
 		/// Perform the optimization
 		virtual bool Optimize(HQRCdata::HKCAppItem^) override;
 
 		/*! \}                                                                 */		
 	};
	
}

